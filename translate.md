[TOC]
# 高效可验证前向安全可搜索对称加密

# Abstract
可搜索对称加密（SSE）允许客户端高效执行搜索存储在不受信任服务器上的加密数据。尽管向前安全SSE可以保证服务器无法将新更新的数据链接到以前搜索的关键字，大多数现有的解决方案只关注诚实但好奇的服务器模型。

如何在恶意服务器模型中实现可验证的前向安全SSE仍然是一个挑战
问题。本文提出一种有效的可验证前向安全SSE方案，同时实现了搜索结果的可验证性和前向安全性。特别地，我们提出了一种新的基于多集原语的可验证数据结构哈希函数，通过增量哈希操作实现有效的可验证数据更新。
与最新的解决方案相比，我们提出的方案在搜索和更新效率，同时提供搜索结果的可验证性。最后，我们提出一个安全性分析并实现我们的方案，这表明我们提出的方案能够达到预期的安全性能和实用效率。

# 1. 介绍

云计算能够方便地按需访问一个集中的可配置计算资源池，该池提供似乎无限的存储和计算服务。随着云计算的快速发展，资源受限的用户更愿意将数据外包给服务器。尽管外包数据有着巨大的好处，但它仍存在安全和隐私问题。根据最近的一份报告，在线社交网络Facebook已经泄露了超过5.4亿条记录（146GB），其中包括用户的Facebook ID、帐户名以及他们的活动[11]。一种解决方案是在外包前使用传统的加密技术对私有数据进行加密。然而，它带来了对加密数据的搜索问题。
可搜索对称加密（SSE）使服务器能够直接搜索加密的数据，这在学术界和工业界都得到了很好的研究[5,8,10,19]。更具体地说，用户将加密文档和搜索索引外包给云服务器。当用户对关键字感兴趣时，他会生成一个搜索令牌并将其提交给服务器。然后服务器执行搜索并返回满意的结果。在实践中，SSE需要支持文档的添加和删除，称为动态SSE。但是，大多数现有的动态方案都会泄漏新添加的文档与以前的查询匹配。Zhang等人。[26]利用上述漏洞，通过注入少量文档，有效地恢复查询关键字的内容。此攻击强调了前向安全SSE方案的必要性[22]。

Bost等人。[2] 提出了第一个有效的前向安全SSE方案$∑o\phi o\varsigma$;。这个想法这个结构的背后是每个关键字对应于一个基于活板门的状态链置换。特别地，当用户想要添加新文档时，他使用陷门置换从以前的状态生成新状态。那么新文件标识符存储在从新状态派生的新位置。注意，使用公钥，
以前的状态可以从当前状态派生。在这种情况下，服务器将生成以前的状态，因此导出相应的位置，以便在给定状态时找到结果。由于用户在执行搜索操作。为了进一步提高效率，Song等人。给出了$∑o\phi o\varsigma$的一个推广，称为FAST[21]。他们认为公钥原语陷门置换是主要的性能瓶颈。因此，他们用对称密码原语代替了它.

请注意，以上所有方案都是在诚实但好奇的云模型中设计的，在该模型中，服务器诚实地执行所有搜索操作并正确地返回所有搜索结果。然而，实际上，云服务器也很可能是恶意的。也就是说，它可能返回不正确和/或不完整的搜索结果。其原因是软硬件故障，或者是服务器的自私行为，如节省带宽或计算资源。为了对抗恶意服务器，可验证的SSE受到了广泛的关注[1,6,16,23,25]。然而，这些可验证的构造只在静态环境下工作。Bost等人。在可验证哈希表（VHT）的基础上，提出了$∑o\phi o\varsigma$;称为$∑o\phi o\varsigma-\epsilon$[4]的可验证版本。然而，VHT必须在每次更新时进行重构，这导致更新效率低和通信成本高。据我们所知，如何构造一个具有前向安全性的有效可验证SSE方案仍然是一个巨大的挑战。挑战来自两个方面。一方面，我们需要在更新数据的同时有效地更新可验证结构。另外，在动态设置中，需要保证服务器不能使用历史数据和证据通过验证。另一方面，更新后的可验证结构不能破坏前向安全性。

## 1.1 我们的贡献
本文主要研究可验证的前向安全SSE结构。我们的贡献可以是
总结如下：

- 提出了一种基于多集散列函数的高效可验证前向安全SSE方案，实现了搜索结果的可验证性，同时维护了前向安全关键字搜索。具体来说，当数据更新发生时，客户机可以增量地生成新的证据。因此，该方案适合于频繁的数据更新。

- 与最先进的解决方案FAST[21]相比，我们提出的方案可以生成一个新的在数据更新过程中不进行（对称）加密操作的随机状态。此外，它还可以实现最佳的搜索效率，因为相应的解密删除操作。

- 我们提供了我们提议的方案的正式安全证明，并对其进行了彻底的实施。实验结果表明，我们的结构具有良好的搜索性和实用性更新效率。


## 1.2 相关工作
可搜索加密是一种在维护可搜索性2000年，Song等人。提出了第一个上证综指方案[19]。随后，本文对SSE进行了一个分支研究，主要集中在提高搜索效率上。Goh在SSE[10]中首次引入搜索索引，搜索效率与文档数成线性关系。2006年，Curtmola等人。在其SSE方案中引入了倒排索引，实现了次线性搜索效率[8]。Cash等人。提出了一种支持布尔查询和子线性搜索效率的静态SSE方案[5]。Kamara等人。2012年首次提出次线性动态SSE方案[13]。作为Kamara的扩展方案继承了子线性搜索效率的优点，但在更新阶段会向服务器泄漏大量信息。

近年来，一些攻击被精心设计来链接以前的搜索标记以学习外包数据为目的的最新文件[9,12]。因此，前向安全的SSE方案引起了广泛的关注。Stefanov等人。首先给出了形式化定义动态SSE中的前向安全概念[22]。Bost提出了一个实用的SSE方案命名为$∑o\phi o\varsigma$;[2]。然而，方案中涉及的公钥原语成为不可避免的性能限制。为了进一步解决这个问题，宋等人。提议的快速和禁食[21]，他们的方案比Bost的方案更有效，因为他们的方案只使用对称加密原语。

SSE方案的另一个关注点是搜索结果的正确性和完整性。Chai等人。提出了可验证SSE的概念，并基于特征树构造了第一个可验证SSE方案[6]。黑泽明和Ohtaki在2012年提出了针对活跃对手的第一个可验证的SSE方案[14]，后来扩展了其方案，以支持2016年的更新操作[15]。Bost等人。提出了$∑o\phi o\varsigma$;，称为$∑o\phi o\varsigma -\epsilon$的可验证版本。文[4]中详细介绍了$∑o\phi o\varsigma -\epsilon$的验证技术。2017年，Yoneyama和Kimura提出了一个基于$∑o\phi o\varsigma$;的新的可验证SSE方案，与$∑o\phi o\varsigma -\epsilon$[15]相比，该方案减少了客户的存储空间。最近，王等人。提出了一种基于累加器的支持连接关键字搜索的可验证SSE方案[25]。

## 1.3 组织
本文的其余部分安排如下。
在第2节中，我们给出了一些初步的内容和我们方案的安全定义。
第3节给出了建议方案及其详细施工。
第4节给出了形式化的安全性和效率分析。
我们在第5节中给出了绩效评估。
第六节的结论。

# 2. 准备工作
在本节中，我们首先描述本工作中使用的符号，如表1所示。然后简单介绍了构造中用到的多集散列函数。之后，我们给出了一个正式的安全定义。

|符号|描述|
|---|---|
|$\lambda$|安全参数|
|$\sum$|存储在客户端的映射|
|$T$|存储在服务器端的地图|
|$ind_i$|第i个文档的标识符|
|$l$|标识符的长度|
|$op$|操作添加或删除的更新操作|
|$DB$|整个数据库的表示|
|$DB（w）$|包含关键字w的文档的所有标识符|
|$DB_i（w）$|状态i下包含w的文档的所有标识符|
|$d$|数据库中关键字文档对的数目|
|$H$|散列函数|
|$F$|伪随机函数|
|$\mathcal{H}$|多集散列函数|
|$hash$|散列多集散列函数的输出|
|$m$|散列的长度|
|R|搜索结果|
|$proof$|证明|

## 2.1多集哈希函数
多集散列函数是Clarke在2003年提出的一种有效的密码工具，它可以将任意有限大小的多集映射成固定长度的字符串。它们不同于标准的散列函数，因为输入是多集而不是字符串。多集散列函数最吸引人的特性是增量。也就是说，当一个新成员被添加到多集时，我们可以在不重新计算整个新输入的情况下快速得到结果。概率多项式时间算法（$\mathcal{H,}+ _{\mathcal{H,}} \equiv _{\mathcal{H}}$）的三重性满足以下三个性质时，它是一个多集散列函数：
- 压缩：$\mathcal{H}$是一种概率算法，它可以将一个多集映射到一个字节数组（一个字节长度$m$的数组）。我们把$\mathcal{H}$的输出称为$hash$。
- 可比性：对于相同的输入，H可以输出不同的散列，因为它是概率的算法。因此，我们需要$\equiv _\mathcal{H}$来比较散列。形式上，关系$\mathcal{H}(M) \equiv _\mathcal{H} \mathcal{H}(M)$
必须保留所有多集$M$。
- 增量：如果在$M$中加入一个新元素$e$，则$\mathcal{H}(M)$可根据
不重新计算的上一个哈希。形式上，$\mathcal{H}(M \cup \{e\}) \equiv _\mathcal{H} \mathcal{H}(M)+ _\mathcal{H} \mathcal{H}(\{e\})$

## 2.2 可验证的动态可搜索对称加密
可搜索对称加密（SSE）方案允许客户端在将数据外包给服务器之前对其进行加密，同时保留对其进行搜索的能力。此外，一个可验证的动态SSE方案允许客户端更新外包数据库并验证搜索结果的完整性。可验证的动态SSE方案  $\prod$ =（Setup，Search，Update，Verify）由三个协议和一个算法组成。

- $（K，\sigma；EDB）\leftarrow 设置（λ，DB；⊥）$：在该协议中，客户端以安全参数λ和数据库DB作为输入和输出（K，σ），其中K是密钥，σ是客户端的状态。服务器输出EDB，它是存储在服务器中的加密数据库。

- $（\sigma'，R，proof；EDB'）\leftarrow 搜索（K，σ，w；EDB）$：这是具有输入（K，σ，w）的客户端和具有输入EDB的服务器之间的协议。在此协议之后，服务器将匹配的结果R和相应的证明返回给客户端。客户端的状态$\sigma$可以更新为$\sigma'$，加密数据库EDB可以更新为$EDB'$。

- $（σ'；EDB'）\leftarrow 更新（K，\sigma，ind，w，op；EDB）$：对于更新协议，客户端的输入是$（K，\sigma，ind，w，op）$，其中ind是标识符，w是关键字，op是操作。没有说明op=add或op=del表示添加或删除关键字文档对。服务器的输入是加密的数据库EDB。在这个协议之后，可以更新$\sigma$和$EDB$。

- $（Accept或Reject）\leftarrow 验证（K，\sigma，R，proof）$：该算法以$（K，\sigma，R，proof）$为输入，其中R和证明由服务器返回。算法用于检查R是否正确和完整。如果是，则算法输出Accept。否则，它输出Reject。


## 2.3 安全定义
由于客户端和服务器之间的通信，所有SSE方案都不可避免地向服务器泄漏信息。因此，我们可以通过描述泄漏信息来给出方案的安全定义。对应于$\prod$=（Setup，Search，Update，Verify），泄漏函数可以定义为$L=\{L_{Setup}，L_{Search}，L_{Update}，L_{Verify\}}$。让一个做对手，我们做模拟器。我们可以定义以下两个概率实验：


- $Real^{\prod}_{\mathcal{A}}{(\lambda)}$：$\mathcal{A}$选择一个安全参数$\lambda$，然后运行Setup（λ，⊥；⊥），并将初始化的数据结构$\sum$和$T$返回给$\mathcal{A}$。$\mathcal{A}$自适应地选择一个关键字w，并通过运行搜索协议的客户端阶段生成查询。实验通过执行搜索$（ks，w，∑；T）$和验证$（w，∑，R，proof）$来回答查询，然后将所有客户机输出给$\mathcal{A}$。对于更新操作，$\mathcal{A}$生成一个查询，然后实验通过运行 更新$（k_s，ind，w，op，∑；T）$来回答查询，并将所有输出返回给对手$\mathcal{A}$。最后，$\mathcal{A}$输出一个位b∈{0，1}作为实验的输出。

- $Ideal^{\prod}_{\mathcal{A,S}}{(\lambda)}$：$\mathcal{A}$选择安全参数λ。给定泄漏函数$L_{Setup}（λ）$，模拟通过运行$S（L_{Setup}（λ））$生成空数据结构∑和T并将其返回给$\mathcal{A}$。然后$\mathcal{A}$自适应地选择搜索或验证查询q。模拟器通过执行$S（L_{Search}（q））$或$S（L_{Verify}（q））$来回答查询。对于更新操作，模拟器通过运行$S（L_{Update}（q））$来回答更新查询。最后，对手$\mathcal{A}$输出一个位b∈{0，1}作为实验的输出。

    我们称$\prod$是L-自适应安全的可搜索对称加密方案，如果对于任何概率多项式时间的对手$\mathcal{A}$，存在这样一个模拟器S：


$$|Pr(Real^{\prod}_{\mathcal{A}}{(\lambda = 1)})-Pr(Ideal^{\prod}_{\mathcal{A,S}}{(\lambda = 1)})| \lneq negl(\lambda)$$

## 2.4 泄漏功能
SSE方案的设计思想是允许用户在尽可能少地泄露信息的同时高效地搜索加密数据。类似于[2,21]，我们将用泄漏函数$L$来描述我们的方案的安全性。我们假设$L$保留查询历史$Hist=(DB_i，q_i)^{Q}_{i=0}$其中包含到目前为止发出的所有查询以及与$q_i$对应的数据库快照。条目是$q_i=（i，w）$用于关键字$w$的搜索查询，或$q_i=（i，ind，w，op）$用于更新查询，或$q_i=（i，w，R，proof）$用于服务器返回$R$和$proof$的$verify$查询。整数$i$是所有查询的计数器。访问模式$ap$被定义为$ap(Hist)=(t_1,…,t_Q）$。$ap(Hist)的条目是t_i=（i，DB_i（w_i），proof_i）$用于搜索查询，或$t_i=（i，op_i，ind_i，proof_i）$用于更新查询。查询模式$qp$被定义为$qp（w）={i | q_i contains w for each q_i in Hist}。$


## 2.5 远期安全
转发安全性要求以前的搜索标记不能用于匹配新的更新。直观地，更新操作不应显示有关关键字的信息。我们将远期安全的定义描述如下：

定义1。（前向安全）。如果对于更新查询$q_i=（ind_i，w_i，op_i）$，泄漏函数$L update（q_i）=（i，op_i，ind_i）$，则L-自适应安全可搜索对称加密方案是前向安全的。

对于没有前向安全性的动态SSE方案，诚实但好奇的服务器可以保留所有的历史搜索令牌，并检查这些令牌是否匹配新的更新。如果是，则服务器可以得出结论，即与此搜索令牌匹配的关键字包含在新添加的文档中。基于这个想法，张等人。2016年提出对SSE方案进行文件注入攻击[26]。具体地说，服务器将其选择的文件发送到客户端，然后客户端根据SSE方案的要求加密并上载这些文件。通过了解这些文件中包含的关键字，服务器可以轻松地获取与特定搜索令牌相关的关键字。此外，服务器可以知道新更新的文档中包含了哪个关键字。

# 3. 可验证的前向安全SSE方案
在本节中，我们首先介绍一些在工作中使用的构建块。然后，具体提出了可验证的前向安全SSE方案。

## 3.1 高度描述

在动态SSE方案中，客户端数据通过更新协议逐渐外包给服务器。当服务器从客户端接收到搜索请求时，它执行搜索并返回满意的结果。但是，服务器可能是恶意的，在这种情况下，它将返回不正确和/或不完整的搜索结果。因此，客户有必要验证搜索结果的正确性和完整性。注意，在前向安全SSE的设置中，验证完整性有两个挑战。首先，在添加新数据时，客户端必须同步更新服务器端的证明。在这种情况下，服务器可以返回一个历史搜索结果和相应的证明，也可以通过客户端的验证。因此，如何保证返回的搜索结果和证据是最新的，是目前面临的挑战之一。其次，前向安全SSE要求服务器不能将新更新的数据链接到先前搜索的关键字。在我们的可验证前向SSE方案中，证明是更新数据的一部分，因此如何保证证明不损害前向安全性是另一个挑战。

本文提出了一种有效的可验证前向安全SSE方案。我们的方案还采用了$∑o\phi o\varsigma$[2]和FAST[21]方案中使用的状态链思想。如图1所示，每个关键字w对应于状态链，并且匹配的所有标识符w存储在从该链导出的位置。如果客户端想要搜索关键字w，它会将最后一个状态stc+1发送到服务器。服务器可以得到之前所有的状态$st_c，stc_{c-1}，···，st_1$。因此，服务器可以按相反的顺序遍历状态链并得到结果。请注意，服务器无法从当前状态$st_{c+1}$获取下一个状态$st_{c+2}$，这将确保转发安全属性。为了提高搜索和更新效率，我们的方案中随机生成状态。但它也保留了当前状态可用于向后而不是向前生成状态的属性，从而确保了向前的隐私。此外，为了实现可验证的功能，我们需要在更新文档标识符对时生成新的证明。由于多集散列函数的递增性，新的证明可以有效地从前一个证明生成，而不是使用所有的历史标识符来重建。用户在进行验证时，首先需要检查证明是否是最新的，然后再验证搜索结果的完整性。


## 3.2 构造块

Clerk等人。[7] 介绍了四种多集散列函数的构造方法，即MSet-Mu hash、MSet-VAdd hash、MSet-Add hash 和MSet-XOR hash。具体来说，MSet-Mu散列是基于有限域上的乘法运算的，这导致效率低下。MSet-VAdd散列通过向量加法模一个大整数来代替mul-tiplication，从而提高了效率。类似地，MSet-Add Hash通过对一个大数进行加法模来代替乘法，以提高效率。这两种结构都是抗多集冲突的，这意味着很难找到两个能产生相同散列的多集。MSet-XOR哈希是最有效的构造，因为它只使用XOR操作。然而，它被设置为抗冲突（这意味着很难找到能够产生相同散列的集合和多集合）而不是多集合抗冲突。给定多集M，MSet XOR Hash可以定义如下：

$$\mathcal{H}_{K}(r,M) = \mathcal{H}_{K}(0,r) \oplus \bigoplus_{m \in M}\mathcal{H}_K (1,m)$$

$$\mathcal{H}_K(r,M\cup(\{x\})) \equiv _{\mathcal{H}} \mathcal{H}(r,M)+ _\mathcal{H} \mathcal{H}(r,\{x\})\equiv _{\mathcal{H}}\mathcal{H}(r,M)\oplus {H}_K(1,x)$$

$$\mathcal{H}_K(r,M \setminus (\{x\})) \equiv _{\mathcal{H}} \mathcal{H}(r,M)- _\mathcal{H} \mathcal{H}(r,\{x\})\equiv _{\mathcal{H}}\mathcal{H}_K(r,M)\oplus H(1,x)$$


## 3.3 具体构造

在本节中，我们将详细介绍我们提出的方案。如算法1所示，该方案主要由三个协议和一个算法组成。我们的方案和FAST[21]之间的区别用蓝色突出显示。

- 设置（λ，⊥⊥）：客户端以安全参数λ作为输入，然后从{0，1}λ中随机选择$k_s和k_r$，并初始化一个空映射∑，以存储最新的状态和证明信息。用长期密钥$k_s$生成搜索令牌，用k_r生成多集散列函数的密钥。服务器将空映射T初始化为加密数据库。

- 搜寻（w，∑；T）：要对w执行搜索查询，客户端首先从∑[w]获取$（st_c，hash）$，如果$（st_c，hash）$为空，协议将返回一个空集，在这种情况下，没有与w匹配的文档，否则客户端生成$t_w$并发送$（t_w，st_c）$到服务器。在获取$（t_w，st_c）$时，服务器首先从最后一个状态获取证据（将返回给客户端）。然后它生成当前状态的位置，并解密密文以获得前一状态。通过迭代，服务器可以得到与w对应的所有状态。注意，我们可以删除其他未链接到最后一个状态的证明，以释放服务器的存储空间。

- 更新（∑，ind，w，op；T）：要添加或删除条目（w，ind），需要更新加密数据库和凭证。首先，客户端随机选择一个新的状态$st_{c+1}$。假设$H_1：\{0，1\}^{*} \leftarrow \{0，1\}^n$和$H2：\{0，1\}^{*} \leftarrow \{0，1\}^{λ+l+1}$是两个散列函数，$F_1和F_2$是两个伪随机函数。服务器按$H_2$加密（op，ind，stc）并按$H_1$计算位置信息。为了更新证明，$ind和st_{c+1}$被添加到multiset，而$st_c$被删除。由于多集散列函数的增量特性，更新操作非常有效。最后，客户端将位置、密文和更新的证明发送到服务器。

- 验证（w，∑，R，proof）：为了验证R的完整性，客户端首先保证返回的证明是最新的。唯一需要做的是将返回的证据与存储在∑中的抄本进行比较。此外，为了验证R的正确性和完整性，客户端需要重新计算多集散列函数，并将输出与返回的证明进行比较。如果以上两个测试都通过了，就可以保证查询的完整性。

# 4. 安全和效率分析
在这一部分中，我们首先介绍了基于仿真的方法的安全性。

Algorithm 1 Verifiable Forward Secure SSE

## 4.1 安全性分析
我们介绍了搜索模式$sp（w）$和更新历史$uh（w）$。搜索模式定义为$sp（w）=\{i | for each（i，w）in Q\}$，它显示$w$上的所有搜索查询，更新历史$uh（w）=\{（i，opi，indi）for each（i，indi，wi，opi）in Hist\}$。很明显，$sp（w）$和$uh（w）$可以从$（ap（），qp（））$中获得。与文献[2,21]不同，我们的方案额外泄漏了更新协议中的证明信息。证明历史$ph（w）=\{（i，proof_i）|for each（i，ind_i，w_i，op_i）in Hist\}$ 显示每个更新查询$q_i$对应的所有证明。

定理1。将$泄漏 L=\{L_{Setup}，L_{Search}，L_{Update}，L_{Verify}\}$定义为

$$
\begin{cases}
L_{Setup} = \bot \\
L_{Search} = (sp(w),uh(w)) \\
L_{Update} = (ph(w))\\
L_{Verify} = (sp(w),proof)
\end{cases}$$

该方案是一种具有前向安全性的L-自适应安全动态SSE。


定理1的证明是由一系列不可区分的杂交子来完成的。第一个杂交子是现实世界的游戏，最后一个混血儿是创意世界的游戏。在第一场比赛中，我们用表**Key**和**Rw**替换了两个PRF $F_1和F_2$。在第二个混合体中，$H_1$被建模为一个随机预言。我们用更新协议中$\{0，1\}^n$中随机选择的字符串替换hash函数$H_1$。然后，游戏将在搜索协议期间对随机预言进行编程，以便我们可以生成正确的结果。类似地，$H_2$在第三个混合体中被建模为一个随机预言机。注意，多集散列函数也基于标准散列函数，因此第四个混合函数可以将其建模为随机oracle。最后，我们只使用$sp（w）、uh（w）、R$和证明来构造一个与以前的混合体不同的混合体。由于这种混合只需要泄漏函数的输出就可以运行，这就意味着我们有了一个与真实游戏不可区分的模拟器。一个更正式的声明可以在附录中找到。

## 4.2 比较
在本节中，我们将我们的方案与FAST[21]、$∑o\phi o\varsigma$和$∑o\phi o\varsigma-\epsilon$[2]进行了比较。首先，这四种方案都能实现前向安全，只有我们的方案$∑o\phi o\varsigma-\epsilon$才能保证搜索结果的可验证性。我们的方案可以看作是FAST的扩展，以提高搜索效率和支持搜索结果的可验证性。

我们用TP 陷门置换表示，$t_{TP}$表示TP的时间代价，P表示标准置换，$T_P$表示TP的时间代价，$t_{H}$表示标准哈希函数的时间代价，$t_{\mathcal{H}}$表示多集哈希函数的时间代价，$t_{VHT}$表示重构可验证哈希表的时间代价。$U_w$是关于关键字w的更新操作的次数，即关键字w在数据库中历史上被添加和删除的次数。表2给出了上述四种方案的性能比较。

# 5 绩效评估

在这一部分中，我们将对我们提出的方案进行全面的性能评估。我们在C/C++中实现了我们的方案，并使用crypto++库来实例化了密码操作：针对PRF $F_1和F_2$，SHA256的CTR模型中的AES，用于Hash函数$H_1和H_2$。我们通过与$∑o\phi o\varsigma$[2]、$∑o\phi o\varsigma-\epsilon$[2]和FAST[21]的比较来评估所提出的方案。对于所有这些方案，我们使用Rocksdb将数据存储在客户端和服务器端，并使用gRPC实现它们之间的通信。标识符的长度在所有方案中都是相同的。在我们的方案中，我们将对称密钥的长度设置为128位。匹配的文档数量从10个到100000个不等。

我们在一台桌面计算机上评估我们的方案，该计算机有4个内核，8个线程（Intel Xeon E5-1620 v3，3.50 GHz）、16 GB RAM和1 TB磁盘，运行在Ubuntu14.04 LTS上。借用了$∑o\phi o\varsigma$〔3〕和FAST〔20〕的C++实现，进行了比较。我们的代码是开源的[27]。注意，可验证散列表[17,18,24]有许多构造，但是$∑o\phi o \varsigma-\epsilon$没有指定使用哪一个。因此，我们通过评估重建哈希表来简单地评估$∑o\phi o\varsigma-\epsilon$的更新效率。

**搜索效率**。图2（a）示出了搜索协议的评估结果。我们可以看到，当匹配的文档数量增加时，每个匹配条目的搜索时间减少原因是这些方案在搜索协议中都有一些初始化操作，这些一次性的代价高昂的操作被分摊到搜索结果的每个条目中。由于在$∑o\phi o\varsigma$的搜索协议中涉及到公钥原语，因此$∑o\phi o\varsigma$的每一个匹配项的搜索时间比我们的方案都要长，而且速度快。协议需要进行陷门置换以从当前状态获取先前状态。我们的方案和FAST都只使用对称密钥操作，但是一个额外的陷门置换操作应该在FAST中执行。因此，我们的方案比$∑o\phi o\varsigma$性能好，而且速度快。

**更新效率**。图2（b）示出了更新操作的性能。请注意，由RPC通信和磁盘访问引起的延迟包含在我们的评估中。直观地说，更新协议的瓶颈是计算新的更新令牌。在更新协议中，$∑o\phi o\varsigma$的更新时间是最大的，因为它需要执行陷门置换（公钥原语）。对于FAST，更新协议由一个置换和两个散列函数组成。对于我们的方案，更新协议包括一个多集散列函数和两个散列函数的更新操作。注意，在我们的方案中，MHT的更新操作实际上是一个哈希函数操作。因此，FAST的更新性能与我们的方案之间的差异取决于置换操作和散列函数的性能。随着关键字文档对数量的增加，这种差异变得越来越明显。

表3显示了三种方案的更新操作吞吐量和单关键字文档对的更新时间。如我们所见，我们的方案的吞吐量大约是FAST的1.7倍，大约是$∑o\phi o\varsigma$的19倍。实验结果表明，该方案在更新效率方面保持了可比的性能。

**搜索效率**。图2（c）示出验证操作的性能。我们的方案比$∑o\phi o\varsigma-\epsilon$更好，因为它涉及可验证哈希表的额外重建。正如我们所看到的，随着关键字文档对数量的增加，这种差异变得越来越明显。原因是重建哈希表的时间开销与其中的元素数成正比。

# 6 结论
本文研究了恶意环境下的前向安全SSE问题。基于多集散列函数的基元，提出了一种新的高效可验证前向安全SSE，保证了查询的完整性和前向安全性。我们提供了一个正式的安全证明，证明我们的方案能够达到预期的安全目标。此外，我们实现了我们的方案，实验结果表明，所提出的方案能够提供可比的性能。