# 高效可验证前向安全可搜索对称加密

# Abstract
可搜索对称加密（SSE）允许客户端高效执行搜索存储在不受信任服务器上的加密数据。尽管向前安全SSE可以保证服务器无法将新更新的数据链接到以前搜索的关键字，大多数现有的解决方案只关注诚实但好奇的服务器模型。

如何在恶意服务器模型中实现可验证的前向安全SSE仍然是一个挑战
问题。本文提出一种有效的可验证前向安全SSE方案，同时实现了搜索结果的可验证性和前向安全性。特别地，我们提出了一种新的基于多集原语的可验证数据结构哈希函数，通过增量哈希操作实现有效的可验证数据更新。
与最新的解决方案相比，我们提出的方案在搜索和更新效率，同时提供搜索结果的可验证性。最后，我们提出一个安全性分析并实现我们的方案，这表明我们提出的方案能够达到预期的安全性能和实用效率。

# 1. 介绍

云计算能够方便地按需访问一个集中的可配置计算资源池，该池提供似乎无限的存储和计算服务。随着云计算的快速发展，资源受限的用户更愿意将数据外包给服务器。尽管外包数据有着巨大的好处，但它仍存在安全和隐私问题。根据最近的一份报告，在线社交网络Facebook已经泄露了超过5.4亿条记录（146GB），其中包括用户的Facebook ID、帐户名以及他们的活动[11]。一种解决方案是在外包前使用传统的加密技术对私有数据进行加密。然而，它带来了对加密数据的搜索问题。
可搜索对称加密（SSE）使服务器能够直接搜索加密的数据，这在学术界和工业界都得到了很好的研究[5,8,10,19]。更具体地说，用户将加密文档和搜索索引外包给云服务器。当用户对关键字感兴趣时，他会生成一个搜索令牌并将其提交给服务器。然后服务器执行搜索并返回满意的结果。在实践中，SSE需要支持文档的添加和删除，称为动态SSE。但是，大多数现有的动态方案都会泄漏新添加的文档与以前的查询匹配。Zhang等人。[26]利用上述漏洞，通过注入少量文档，有效地恢复查询关键字的内容。此攻击强调了前向安全SSE方案的必要性[22]。

Bost等人。[2] 提出了第一个有效的前向安全SSE方案$∑o\phi o\varsigma$;。这个想法这个结构的背后是每个关键字对应于一个基于活板门的状态链置换。特别地，当用户想要添加新文档时，他使用陷门置换从以前的状态生成新状态。那么新文件标识符存储在从新状态派生的新位置。注意，使用公钥，
以前的状态可以从当前状态派生。在这种情况下，服务器将生成以前的状态，因此导出相应的位置，以便在给定状态时找到结果。由于用户在执行搜索操作。为了进一步提高效率，Song等人。给出了$∑o\phi o\varsigma$的一个推广，称为FAST[21]。他们认为公钥原语陷门置换是主要的性能瓶颈。因此，他们用对称密码原语代替了它.

请注意，以上所有方案都是在诚实但好奇的云模型中设计的，在该模型中，服务器诚实地执行所有搜索操作并正确地返回所有搜索结果。然而，实际上，云服务器也很可能是恶意的。也就是说，它可能返回不正确和/或不完整的搜索结果。其原因是软硬件故障，或者是服务器的自私行为，如节省带宽或计算资源。为了对抗恶意服务器，可验证的SSE受到了广泛的关注[1,6,16,23,25]。然而，这些可验证的构造只在静态环境下工作。Bost等人。在可验证哈希表（VHT）的基础上，提出了$∑o\phi o\varsigma$;，称为$∑o\phi o\varsigma-\epsilon$[4]的可验证版本。然而，VHT必须在每次更新时进行重构，这导致更新效率低和通信成本高。据我们所知，如何构造一个具有前向安全性的有效可验证SSE方案仍然是一个巨大的挑战。挑战来自两个方面。一方面，我们需要在更新数据的同时有效地更新可验证结构。另外，在动态设置中，需要保证服务器不能使用历史数据和证据通过验证。另一方面，更新后的可验证结构不能破坏前向安全性。

## 1.1 我们的贡献
本文主要研究可验证的前向安全SSE结构。我们的贡献可以是
总结如下：
- 提出了一种基于多集散列函数的高效可验证前向安全SSE方案，实现了搜索结果的可验证性，同时维护了前向安全关键字搜索。具体来说，当数据更新发生时，客户机可以增量地生成新的证据。因此，该方案适合于频繁的数据更新。
- 与最先进的解决方案FAST[21]相比，我们提出的方案可以生成一个新的
在数据更新过程中不进行（对称）加密操作的随机状态。此外，它还可以实现最佳的搜索效率，因为相应的解密删除操作。
- 我们提供了我们提议的方案的正式安全证明，并对其进行了彻底的实施。实验结果表明，我们的结构具有良好的搜索性和实用性更新效率。


## 1.2 相关工作
可搜索加密是一种在维护可搜索性2000年，Song等人。提出了第一个上证综指方案[19]。随后，本文对SSE进行了一个分支研究，主要集中在提高搜索效率上。Goh在SSE[10]中首次引入搜索索引，搜索效率与文档数成线性关系。2006年，Curtmola等人。在其SSE方案中引入了倒排索引，实现了次线性搜索效率[8]。Cash等人。提出了一种支持布尔查询和子线性搜索效率的静态SSE方案[5]。Kamara等人。2012年首次提出次线性动态SSE方案[13]。作为Kamara的扩展方案继承了子线性搜索效率的优点，但在更新阶段会向服务器泄漏大量信息。

近年来，一些攻击被精心设计来链接以前的搜索标记以学习外包数据为目的的最新文件[9,12]。因此，前向安全的SSE方案引起了广泛的关注。Stefanov等人。首先给出了形式化定义动态SSE中的前向安全概念[22]。Bost提出了一个实用的SSE方案命名为$∑o\phi o\varsigma$;[2]。然而，方案中涉及的公钥原语成为不可避免的性能限制。为了进一步解决这个问题，宋等人。提议的快速和禁食[21]，他们的方案比Bost的方案更有效，因为他们的方案只使用对称加密原语。

SSE方案的另一个关注点是搜索结果的正确性和完整性。Chai等人。提出了可验证SSE的概念，并基于特征树构造了第一个可验证SSE方案[6]。黑泽明和Ohtaki在2012年提出了针对活跃对手的第一个可验证的SSE方案[14]，后来扩展了其方案，以支持2016年的更新操作[15]。Bost等人。提出了$∑o\phi o\varsigma$;，称为$∑o\phi o\varsigma -\epsilon$的可验证版本。文[4]中详细介绍了$∑o\phi o\varsigma -\epsilon$的验证技术。2017年，Yoneyama和Kimura提出了一个基于$∑o\phi o\varsigma$;的新的可验证SSE方案，与$∑o\phi o\varsigma -\epsilon$[15]相比，该方案减少了客户的存储空间。最近，王等人。提出了一种基于累加器的支持连接关键字搜索的可验证SSE方案[25]。

## 1.3 组织
本文的其余部分安排如下。
在第2节中，我们给出了一些初步的内容和我们方案的安全定义。
第3节给出了建议方案及其详细施工。
第4节给出了形式化的安全性和效率分析。
我们在第5节中给出了绩效评估。
第六节的结论。

# 2. 准备工作
在本节中，我们首先描述本工作中使用的符号，如表1所示。然后简单介绍了构造中用到的多集散列函数。之后，我们给出了一个正式的安全定义。

|符号|描述|
|---|---|
|$\lambda$|安全参数|
|$\sum$|存储在客户端的映射|
|$T$|存储在服务器端的地图|
|$ind_i$|第i个文档的标识符|
|$l$|标识符的长度|
|$op$|操作添加或删除的更新操作|
|$DB$|整个数据库的表示|
|$DB（w）$|包含关键字w的文档的所有标识符|
|$DB_i（w）$|状态i下包含w的文档的所有标识符|
|$d$|数据库中关键字文档对的数目|
|$H$|散列函数|
|$F$|伪随机函数|
|$\mathcal{H}$|多集散列函数|
|$hash$|散列多集散列函数的输出|
|$m$|散列的长度|
|R|搜索结果|
|$proof$|证明|

## 2.1多集哈希函数
多集散列函数是Clarke在2003年提出的一种有效的密码工具，它可以将任意有限大小的多集映射成固定长度的字符串。它们不同于标准的散列函数，因为输入是多集而不是字符串。多集散列函数最吸引人的特性是增量。也就是说，当一个新成员被添加到多集时，我们可以在不重新计算整个新输入的情况下快速得到结果。概率多项式时间算法（$\mathcal{H,}+ _{\mathcal{H,}} \equiv _{\mathcal{H}}$）的三重性满足以下三个性质时，它是一个多集散列函数：
- 压缩：$\mathcal{H}$是一种概率算法，它可以将一个多集映射到一个字节数组（一个字节长度$m$的数组）。我们把$\mathcal{H}$的输出称为$hash$。
- 可比性：对于相同的输入，H可以输出不同的散列，因为它是概率的算法。因此，我们需要$\equiv _\mathcal{H}$来比较散列。形式上，关系$\mathcal{H}(M) \equiv _\mathcal{H} \mathcal{H}(M)$
必须保留所有多集$M$。
- 增量：如果在$M$中加入一个新元素$e$，则$\mathcal{H}(M)$可根据
不重新计算的上一个哈希。形式上，$\mathcal{H}(M \cup \{e\}) \equiv _\mathcal{H} \mathcal{H}(M)+ _\mathcal{H} \mathcal{H}(\{e\})$


