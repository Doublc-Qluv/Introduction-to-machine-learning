[TOC]

# 第四章
本章节主要展示研究可验证的前向安全SSE结构。我们的贡献总结如下：

- 提出了一种基于多集散列函数的高效可验证前向安全SSE方案，实现了搜索结果的可验证性，同时维护了前向安全关键字搜索。具体来说，当数据更新发生时，客户机可以增量地生成新的证据。因此，该方案适合于频繁的数据更新。

- 与最先进的解决方案FAST[21]相比，我们提出的方案可以生成一个新的在数据更新过程中不进行（对称）加密操作的随机状态。此外，它还可以实现最佳的搜索效率，因为相应的解密删除操作。

- 我们提供了我们提议的方案的正式安全证明，并对其进行了彻底的实施。实验结果表明，我们的结构具有良好的搜索性和实用性更新效率。

## 4.1 准备与知识
在本节中，我们首先描述本工作中使用的符号，如表1所示。

然后,简单介绍了构造中用到的多集散列函数。

之后，我们给出了一个正式的安全定义。

表1 符号说明

|符号|描述|
|---|---|
|$\lambda$|安全参数|
|$\sum$|存储在客户端的映射|
|$T$|存储在服务器端的地图|
|$ind_i$|第i个文档的标识符|
|$l$|标识符的长度|
|$op$|操作添加或删除的更新操作|
|$DB$|整个数据库的表示|
|$DB（w）$|包含关键字w的文档的所有标识符|
|$DB_i（w）$|状态i下包含w的文档的所有标识符|
|$d$|数据库中关键字文档对的数目|
|$H$|散列函数|
|$F$|伪随机函数|
|$\mathcal{H}$|多集散列函数|
|$hash$|散列多集散列函数的输出|
|$m$|散列的长度|
|R|搜索结果|
|$proof$|证明|


### 4.1.1多集哈希函数

多集散列函数是Clarke在2003年提出的一种有效的密码工具，它可以将任意有限大小的多集映射成固定长度的字符串。它们不同于标准的散列函数，因为输入是多集而不是字符串。多集散列函数最吸引人的特性是增量。也就是说，当一个新成员被添加到多集时，我们可以在不重新计算整个新输入的情况下快速得到结果。概率多项式时间算法（$\mathcal{H,}+ _{\mathcal{H,}} \equiv _{\mathcal{H}}$）的三重性满足以下三个性质时，它是一个多集散列函数：

- 压缩：$\mathcal{H}$是一种概率算法，它可以将一个多集映射到一个字节数组（一个字节长度$m$的数组）。我们把$\mathcal{H}$的输出称为$hash$。

- 可比性：对于相同的输入，H可以输出不同的散列，因为它是概率的算法。因此，我们需要$\equiv _\mathcal{H}$来比较散列。形式上，关系$\mathcal{H}(M) \equiv _\mathcal{H} \mathcal{H}(M)$必须保留所有多集$M$。

- 增量：如果在$M$中加入一个新元素$e$，则$\mathcal{H}(M)$可根据
不重新计算的上一个哈希。形式上，$\mathcal{H}(M \cup \{e\}) \equiv _\mathcal{H} \mathcal{H}(M)+ _\mathcal{H} \mathcal{H}(\{e\})$

### 4.1.2 可验证的动态可搜索对称加密

可搜索对称加密（SSE）方案允许客户端在将数据外包给服务器之前对其进行加密，同时保留对其进行搜索的能力。此外，一个可验证的动态SSE方案允许客户端更新外包数据库并验证搜索结果的完整性。可验证的动态SSE方案  $\prod$ =（Setup，Search，Update，Verify）由三个协议和一个算法组成。

- $（K，\sigma；EDB）\leftarrow 设置Setup（λ，DB；⊥）$：在该协议中，客户端以安全参数λ和数据库DB作为输入和输出$（K，\sigma）$，其中K是密钥，$\sigma$是客户端的状态。服务器输出EDB，它是存储在服务器中的加密数据库。

- $（\sigma'，R，proof；EDB'）\leftarrow 搜索Search（K，σ，w；EDB）$：这是具有输入（K，σ，w）的客户端和具有输入EDB的服务器之间的协议。在此协议之后，服务器将匹配的结果R和相应的证明返回给客户端。客户端的状态$\sigma$可以更新为$\sigma'$，加密数据库EDB可以更新为$EDB'$。

- $（σ'；EDB'）\leftarrow 更新Update（K，\sigma，ind，w，op；EDB）$：对于更新协议，客户端的输入是$（K，\sigma，ind，w，op）$，其中ind是标识符，w是关键字，op是操作。没有说明$op=add$或$op=del$表示添加或删除关键字文档对。服务器的输入是加密的数据库EDB。在这个协议之后，可以更新$\sigma$和$EDB$。

- $（Accept或Reject）\leftarrow 验证Verify（K，\sigma，R，proof）$：该算法以$（K，\sigma，R，proof）$为输入，其中R和证明由服务器返回。算法用于检查R是否正确和完整。如果是，则算法输出Accept。否则，它输出Reject。


### 4.1.3 安全定义

由于客户端和服务器之间的通信，所有SSE方案都不可避免地向服务器泄漏信息。因此，我们可以通过描述泄漏信息来给出方案的安全定义。

对应于$\prod$=（Setup，Search，Update，Verify），泄漏函数可以定义为$L=\{L_{Setup}，L_{Search}，L_{Update}，L_{Verify\}}$。让一个做对手，我们做模拟器。我们可以定义以下两个概率实验：


- $Real^{\prod}_{\mathcal{A}}{(\lambda)}$：$\mathcal{A}$选择一个安全参数$\lambda$，然后运行$Setup（λ，\bot；\bot）$，并将初始化的数据结构$\sum$和$T$返回给$\mathcal{A}$。$\mathcal{A}$自适应地选择一个关键字$w$，并通过运行搜索协议的客户端阶段生成查询。实验通过执行$Search（k_s，w，∑；T）$和$Verify（w，∑，R，proof）$来回答查询，然后将所有客户机输出给$\mathcal{A}$。对于更新操作，$\mathcal{A}$生成一个查询，然后实验通过运行$Update（k_s，ind，w，op，∑；T）$来回答查询，并将所有输出返回给对手$\mathcal{A}$。最后，$\mathcal{A}$输出一个位b∈{0，1}作为实验的输出。

- $Ideal^{\prod}_{\mathcal{A,S}}{(\lambda)}$：$\mathcal{A}$选择安全参数λ。给定泄漏函数$L_{Setup}（λ）$，模拟通过运行$S（L_{Setup}（λ））$生成空数据结构∑和T并将其返回给$\mathcal{A}$。然后$\mathcal{A}$自适应地选择搜索或验证查询q。模拟器通过执行$S（L_{Search}（q））$或$S（L_{Verify}（q））$来回答查询。对于更新操作，模拟器通过运行$S（L_{Update}（q））$来回答更新查询。最后，对手$\mathcal{A}$输出一个位$ \mathcal{b} \in \{0，1\}$作为实验的输出。

    我们称$\prod$是L-自适应安全的可搜索对称加密方案，如果对于任何概率多项式时间的对手$\mathcal{A}$，存在这样一个模拟器$S$：


$$|Pr(Real^{\prod}_{\mathcal{A}}{(\lambda = 1)})-Pr(Ideal^{\prod}_{\mathcal{A,S}}{(\lambda = 1)})| \leq negl(\lambda)$$

### 4.1.4 泄漏功能

SSE方案的设计思想是允许用户在尽可能少地泄露信息的同时高效地搜索加密数据。类似于[2,21]，我们将用泄漏函数$L$来描述我们的方案的安全性。我们假设$L$保留查询历史$Hist=(DB_i，q_i)^{Q}_{i=0}$其中包含到目前为止发出的所有查询以及与$q_i$对应的数据库快照。条目是$q_i=（i，w）$用于关键字$w$的搜索查询，或$q_i=（i，ind，w，op）$用于更新查询，或$q_i=（i，w，R，proof）$用于服务器返回$R$和$proof$的$verify$查询。整数$i$是所有查询的计数器。访问模式$ap$被定义为$ap(Hist)=(t_1,…,t_Q）$。$ap(Hist)的条目是t_i=（i，DB_i（w_i），proof_i）$用于搜索查询，或$t_i=（i，op_i，ind_i，proof_i）$用于更新查询。查询模式$qp$被定义为$qp（w）=\{i | q_i\ contains\ w\ for\ each\ q_i\ in\ Hist\}。$


### 4.1.5 前向安全
转发安全性要求以前的搜索标记不能用于匹配新的更新。直观地，更新操作不应显示有关关键字的信息。我们将前向安全的定义描述如下：

定义1。（前向安全）。如果对于更新查询$q_i=（ind_i，w_i，op_i）$，泄漏函数$L update（q_i）=（i，op_i，ind_i）$，则L-自适应安全可搜索对称加密方案是前向安全的。

对于没有前向安全性的动态SSE方案，诚实但好奇的服务器可以保留所有的历史搜索令牌，并检查这些令牌是否匹配新的更新。如果是，则服务器可以得出结论，即与此搜索令牌匹配的关键字包含在新添加的文档中。基于这个想法，张等人。2016年提出对SSE方案进行文件注入攻击[26]。具体地说，服务器将其选择的文件发送到客户端，然后客户端根据SSE方案的要求加密并上载这些文件。通过了解这些文件中包含的关键字，服务器可以轻松地获取与特定搜索令牌相关的关键字。此外，服务器可以知道新更新的文档中包含了哪个关键字。

## 4.2 可验证的前向安全SSE方案
在本节中，我们首先介绍一些在工作中使用的构建块。然后，具体提出了可验证的前向安全SSE方案。

### 4.2.1 高度描述

在动态SSE方案中，客户端数据通过更新协议逐渐外包给服务器。当服务器从客户端接收到搜索请求时，它执行搜索并返回满意的结果。但是，服务器可能是恶意的，在这种情况下，它将返回不正确和/或不完整的搜索结果。因此，客户有必要验证搜索结果的正确性和完整性。注意，在前向安全SSE的设置中，验证完整性有两个挑战。首先，在添加新数据时，客户端必须同步更新服务器端的证明。在这种情况下，服务器可以返回一个历史搜索结果和相应的证明，也可以通过客户端的验证。因此，如何保证返回的搜索结果和证据是最新的，是目前面临的挑战之一。其次，前向安全SSE要求服务器不能将新更新的数据链接到先前搜索的关键字。在我们的可验证前向SSE方案中，证明是更新数据的一部分，因此如何保证证明不损害前向安全性是另一个挑战。

本文提出了一种有效的可验证前向安全SSE方案。我们的方案还采用了$∑o\phi o\varsigma$[2]和FAST[21]方案中使用的状态链思想。如图1所示，每个关键字w对应于状态链，并且匹配的所有标识符w存储在从该链导出的位置。如果客户端想要搜索关键字$w$，它会将最后一个状态$st_{c+1}$发送到服务器。服务器可以得到之前所有的状态$st_c，st_{c-1}，···，st_1$。因此，服务器可以按相反的顺序遍历状态链并得到结果。请注意，服务器无法从当前状态$st_{c+1}$获取下一个状态$st_{c+2}$，这将确保转发安全属性。为了提高搜索和更新效率，我们的方案中随机生成状态。但它也保留了当前状态可用于向后而不是向前生成状态的属性，从而确保了向前的隐私。此外，为了实现可验证的功能，我们需要在更新文档标识符对时生成新的证明。由于多集散列函数的递增性，新的证明可以有效地从前一个证明生成，而不是使用所有的历史标识符来重建。用户在进行验证时，首先需要检查证明是否是最新的，然后再验证搜索结果的完整性。


### 4.2.2 构造块

Clerk等人[7] 介绍了四种多集散列函数的构造方法，即MSet-Mu hash、MSet-VAdd hash、MSet-Add hash 和MSet-XOR hash。具体来说，MSet-Mu散列是基于有限域上的乘法运算的，这导致效率低下。MSet-VAdd散列通过向量加法模一个大整数来代替mul-tiplication，从而提高了效率。类似地，MSet-Add Hash通过对一个大数进行加法模来代替乘法，以提高效率。这两种结构都是抗多集冲突的，这意味着很难找到两个能产生相同散列的多集。MSet-XOR哈希是最有效的构造，因为它只使用XOR操作。然而，它被设置为抗冲突（这意味着很难找到能够产生相同散列的集合和多集合）而不是多集合抗冲突。给定多集M，MSet-XOR Hash可以定义如下：

$$\mathcal{H}_{K}(r,M) = \mathcal{H}_{K}(0,r) \oplus \bigoplus_{m \in M}\mathcal{H}_K (1,m)$$

$$\mathcal{H}_K(r,M\cup(\{x\})) \equiv _{\mathcal{H}} \mathcal{H}(r,M)+ _\mathcal{H} \mathcal{H}(r,\{x\})\equiv _{\mathcal{H}}\mathcal{H}(r,M)\oplus {H}_K(1,x)$$

$$\mathcal{H}_K(r,M \setminus (\{x\})) \equiv _{\mathcal{H}} \mathcal{H}(r,M)- _\mathcal{H} \mathcal{H}(r,\{x\})\equiv _{\mathcal{H}}\mathcal{H}_K(r,M)\oplus H(1,x)$$


### 4.2.3 具体构造

在本节中，我们将详细介绍我们提出的方案。如算法1所示，该方案主要由三个协议和一个算法组成。我们的方案和FAST[21]之间的区别用蓝色突出显示。

- 设置（λ，⊥；⊥）：客户端以安全参数λ作为输入，然后从{0，1}λ中随机选择$k_s和k_r$，并初始化一个空映射∑，以存储最新的状态和证明信息。用长期密钥$k_s$生成搜索令牌，用k_r生成多集散列函数的密钥。服务器将空映射T初始化为加密数据库。

- 搜寻（w，∑；T）：要对w执行搜索查询，客户端首先从∑[w]获取$（st_c，hash）$，如果$（st_c，hash）$为空，协议将返回一个空集，在这种情况下，没有与w匹配的文档，否则客户端生成$t_w$并发送$（t_w，st_c）$到服务器。在获取$（t_w，st_c）$时，服务器首先从最后一个状态获取证据（将返回给客户端）。然后它生成当前状态的位置，并解密密文以获得前一状态。通过迭代，服务器可以得到与w对应的所有状态。注意，我们可以删除其他未链接到最后一个状态的证明，以释放服务器的存储空间。

- 更新（∑，ind，w，op；T）：要添加或删除条目（w，ind），需要更新加密数据库和凭证。首先，客户端随机选择一个新的状态$st_{c+1}$。假设$H_1：\{0，1\}^{*} \leftarrow \{0，1\}^n$和$H2：\{0，1\}^{*} \leftarrow \{0，1\}^{λ+l+1}$是两个散列函数，$F_1和F_2$是两个伪随机函数。服务器按$H_2$加密（op，ind，stc）并按$H_1$计算位置信息。为了更新证明，$ind和st_{c+1}$被添加到multiset，而$st_c$被删除。由于多集散列函数的增量特性，更新操作非常有效。最后，客户端将位置、密文和更新的证明发送到服务器。

- 验证（w，∑，R，proof）：为了验证R的完整性，客户端首先保证返回的证明是最新的。唯一需要做的是将返回的证据与存储在∑中的抄本进行比较。此外，为了验证R的正确性和完整性，客户端需要重新计算多集散列函数，并将输出与返回的证明进行比较。如果以上两个测试都通过了，就可以保证查询的完整性。